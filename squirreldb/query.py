"""
SquirrelDB Python SDK - Query Builder
Generated by sdk-generator v0.1.0
DO NOT EDIT MANUALLY
"""

from __future__ import annotations
from dataclasses import dataclass, field as dataclass_field
from typing import Any, Callable, Literal, TypedDict
import json


SortDirection = Literal["asc", "desc"]


@dataclass
class FilterCondition:
    """A single filter condition."""
    field: str
    operator: str
    value: Any


@dataclass
class SortSpec:
    """Sort specification for a field."""
    field: str
    direction: SortDirection


class ChangesOptions(TypedDict, total=False):
    """Options for change subscriptions."""
    include_initial: bool


class StructuredQuery(TypedDict, total=False):
    """Structured query object (wire format)."""
    table: str
    filter: dict[str, Any]
    sort: list[dict[str, Any]]
    limit: int
    skip: int
    changes: ChangesOptions


class FieldExpr:
    """Field expression for building filter conditions."""

    def __init__(self, field_name: str) -> None:
        self._field_name = field_name

    def eq(self, value: Any) -> FilterCondition:
        """Equal to."""
        return FilterCondition(self._field_name, "$eq", value)

    def ne(self, value: Any) -> FilterCondition:
        """Not equal to."""
        return FilterCondition(self._field_name, "$ne", value)

    def gt(self, value: Any) -> FilterCondition:
        """Greater than."""
        return FilterCondition(self._field_name, "$gt", value)

    def gte(self, value: Any) -> FilterCondition:
        """Greater than or equal to."""
        return FilterCondition(self._field_name, "$gte", value)

    def lt(self, value: Any) -> FilterCondition:
        """Less than."""
        return FilterCondition(self._field_name, "$lt", value)

    def lte(self, value: Any) -> FilterCondition:
        """Less than or equal to."""
        return FilterCondition(self._field_name, "$lte", value)

    def is_in(self, values: list[Any]) -> FilterCondition:
        """Value in array."""
        return FilterCondition(self._field_name, "$in", values)

    def not_in(self, values: list[Any]) -> FilterCondition:
        """Value not in array."""
        return FilterCondition(self._field_name, "$nin", values)

    def contains(self, value: str) -> FilterCondition:
        """String contains substring."""
        return FilterCondition(self._field_name, "$contains", value)

    def starts_with(self, value: str) -> FilterCondition:
        """String starts with prefix."""
        return FilterCondition(self._field_name, "$startsWith", value)

    def ends_with(self, value: str) -> FilterCondition:
        """String ends with suffix."""
        return FilterCondition(self._field_name, "$endsWith", value)

    def exists(self, value: bool = True) -> FilterCondition:
        """Field exists (or not)."""
        return FilterCondition(self._field_name, "$exists", value)


class DocProxy:
    """Document proxy for fluent field access."""

    def __getattr__(self, name: str) -> FieldExpr:
        return FieldExpr(name)


class QueryBuilder:
    """Query builder for constructing SquirrelDB queries."""

    def __init__(self, table_name: str) -> None:
        self._table_name = table_name
        self._filters: list[FilterCondition] = []
        self._sorts: list[SortSpec] = []
        self._limit_value: int | None = None
        self._skip_value: int | None = None
        self._changes_opts: ChangesOptions | None = None

    def find(
        self,
        condition: FilterCondition
        | list[FilterCondition]
        | Callable[[DocProxy], FilterCondition | list[FilterCondition]],
    ) -> QueryBuilder:
        """Add filter conditions using callback or object."""
        if callable(condition):
            result = condition(DocProxy())
            if isinstance(result, list):
                self._filters.extend(result)
            else:
                self._filters.append(result)
        elif isinstance(condition, list):
            self._filters.extend(condition)
        else:
            self._filters.append(condition)
        return self

    def sort(
        self, field_name: str, direction: SortDirection = "asc"
    ) -> QueryBuilder:
        """Add sort specification."""
        self._sorts.append(SortSpec(field_name, direction))
        return self

    def limit(self, n: int) -> QueryBuilder:
        """Set maximum number of results."""
        self._limit_value = n
        return self

    def skip(self, n: int) -> QueryBuilder:
        """Set number of results to skip."""
        self._skip_value = n
        return self

    def changes(
        self, options: ChangesOptions | None = None
    ) -> QueryBuilder:
        """Subscribe to changes."""
        self._changes_opts = options or {"include_initial": True}
        return self

    def compile_structured(self) -> StructuredQuery:
        """Compile to structured query object."""
        query: StructuredQuery = {"table": self._table_name}

        if self._filters:
            query["filter"] = self._build_filter_object()

        if self._sorts:
            query["sort"] = [
                {"field": s.field, "direction": s.direction}
                for s in self._sorts
            ]

        if self._limit_value is not None:
            query["limit"] = self._limit_value

        if self._skip_value is not None:
            query["skip"] = self._skip_value

        if self._changes_opts is not None:
            query["changes"] = self._changes_opts

        return query

    def compile(self) -> str:
        """Compile to JSON string."""
        return json.dumps(self.compile_structured())

    def _build_filter_object(self) -> dict[str, Any]:
        filter_obj: dict[str, dict[str, Any]] = {}
        for cond in self._filters:
            if cond.field not in filter_obj:
                filter_obj[cond.field] = {}
            filter_obj[cond.field][cond.operator] = cond.value
        return filter_obj


def table(name: str) -> QueryBuilder:
    """Create a new query builder for a table."""
    return QueryBuilder(name)


def field_expr(name: str) -> FieldExpr:
    """Create a field expression for filtering."""
    return FieldExpr(name)


def and_(*conditions: FilterCondition) -> FilterCondition:
    """Combine conditions with AND."""
    return FilterCondition("$and", "$and", list(conditions))


def or_(*conditions: FilterCondition) -> FilterCondition:
    """Combine conditions with OR."""
    return FilterCondition("$or", "$or", list(conditions))


def not_(condition: FilterCondition) -> FilterCondition:
    """Negate a condition."""
    return FilterCondition("$not", "$not", condition)
