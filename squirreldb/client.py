"""
SquirrelDB Python SDK - Client
Generated by sdk-generator v0.1.0
DO NOT EDIT MANUALLY
"""

import asyncio
import json
import uuid
from typing import Any, Callable, Optional
from websockets import connect as ws_connect

from .types import Document, ChangeEvent


class SquirrelDB:
    """SquirrelDB WebSocket client"""

    def __init__(self, url: str):
        self._url = url if url.startswith("ws://") or url.startswith("wss://") else f"ws://{url}"
        self._ws = None
        self._pending: dict[str, asyncio.Future] = {}
        self._subscriptions: dict[str, Callable[[ChangeEvent], None]] = {}
        self._listener_task: Optional[asyncio.Task] = None

    @classmethod
    async def connect(cls, url: str) -> "SquirrelDB":
        """Connect to SquirrelDB server"""
        client = cls(url)
        await client._connect()
        return client

    async def _connect(self) -> None:
        self._ws = await ws_connect(self._url)
        self._listener_task = asyncio.create_task(self._listen())

    async def _listen(self) -> None:
        try:
            async for message in self._ws:
                await self._handle_message(json.loads(message))
        except Exception:
            pass

    async def _handle_message(self, msg: dict) -> None:
        msg_type = msg.get("type")

        if msg_type == "Pong":
            return

        if msg_type in ("Result", "Error", "Subscribed", "Unsubscribed", "Collections"):
            msg_id = msg.get("id")
            if msg_id and msg_id in self._pending:
                future = self._pending.pop(msg_id)
                if msg_type == "Error":
                    future.set_exception(Exception(msg.get("message", "Unknown error")))
                else:
                    future.set_result(msg)

        elif msg_type == "Change":
            sub_id = msg.get("subscription_id")
            if sub_id and sub_id in self._subscriptions:
                change = ChangeEvent.from_dict(msg.get("change", {}))
                self._subscriptions[sub_id](change)

    async def _send(self, msg: dict) -> dict:
        msg_id = str(uuid.uuid4())
        msg["id"] = msg_id
        future: asyncio.Future = asyncio.get_event_loop().create_future()
        self._pending[msg_id] = future
        await self._ws.send(json.dumps(msg))
        return await future

    async def close(self) -> None:
        """Close the connection"""
        if self._listener_task:
            self._listener_task.cancel()
        if self._ws:
            await self._ws.close()

    async def ping(self) -> None:
        """Ping the server"""
        await self._ws.send(json.dumps({"type": "Ping"}))

    async def list_collections(self) -> list[str]:
        """List all collections"""
        result = await self._send({"type": "ListCollections"})
        return result.get("collections", [])

    async def query(self, query: str) -> list[Document]:
        """Execute a query"""
        result = await self._send({"type": "Query", "query": query})
        return [Document.from_dict(d) for d in result.get("documents", [])]

    async def insert(self, collection: str, data: dict[str, Any]) -> Document:
        """Insert a document"""
        result = await self._send({"type": "Insert", "collection": collection, "data": data})
        docs = result.get("documents", [])
        return Document.from_dict(docs[0]) if docs else None

    async def update(self, collection: str, doc_id: str, data: dict[str, Any]) -> Document:
        """Update a document"""
        result = await self._send({
            "type": "Update",
            "collection": collection,
            "document_id": doc_id,
            "data": data,
        })
        docs = result.get("documents", [])
        return Document.from_dict(docs[0]) if docs else None

    async def delete(self, collection: str, doc_id: str) -> Document:
        """Delete a document"""
        result = await self._send({
            "type": "Delete",
            "collection": collection,
            "document_id": doc_id,
        })
        docs = result.get("documents", [])
        return Document.from_dict(docs[0]) if docs else None

    async def subscribe(
        self, query: str, callback: Callable[[ChangeEvent], None]
    ) -> str:
        """Subscribe to changes"""
        result = await self._send({"type": "Subscribe", "query": query})
        sub_id = result.get("subscription_id")
        self._subscriptions[sub_id] = callback
        return sub_id

    async def unsubscribe(self, subscription_id: str) -> None:
        """Unsubscribe from changes"""
        await self._send({"type": "Unsubscribe", "subscription_id": subscription_id})
        self._subscriptions.pop(subscription_id, None)
