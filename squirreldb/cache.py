"""
SquirrelDB Python SDK - Cache (Redis-compatible)
Generated by sdk-generator v0.1.0
DO NOT EDIT MANUALLY
"""

import asyncio
from typing import Optional


class Cache:
    """Redis-compatible cache client using RESP protocol"""

    def __init__(self, host: str = "localhost", port: int = 6379):
        self._host = host
        self._port = port
        self._reader: Optional[asyncio.StreamReader] = None
        self._writer: Optional[asyncio.StreamWriter] = None

    @classmethod
    async def connect(cls, host: str = "localhost", port: int = 6379) -> "Cache":
        """Connect to cache server"""
        cache = cls(host, port)
        await cache._connect()
        return cache

    async def _connect(self) -> None:
        self._reader, self._writer = await asyncio.open_connection(self._host, self._port)

    async def close(self) -> None:
        """Close the connection"""
        if self._writer:
            self._writer.close()
            await self._writer.wait_closed()

    def _encode(self, *args: str | int) -> bytes:
        parts = [f"*{len(args)}\r\n"]
        for arg in args:
            s = str(arg)
            parts.append(f"${len(s)}\r\n{s}\r\n")
        return "".join(parts).encode()

    async def _read_response(self):
        line = await self._reader.readline()
        if not line:
            raise ConnectionError("Connection closed")

        prefix = chr(line[0])
        data = line[1:].decode().strip()

        if prefix == "+":
            return data
        elif prefix == "-":
            raise Exception(data)
        elif prefix == ":":
            return int(data)
        elif prefix == "$":
            length = int(data)
            if length == -1:
                return None
            value = await self._reader.read(length + 2)
            return value[:-2].decode()
        elif prefix == "*":
            count = int(data)
            if count == -1:
                return None
            return [await self._read_response() for _ in range(count)]

    async def _command(self, *args: str | int):
        self._writer.write(self._encode(*args))
        await self._writer.drain()
        return await self._read_response()

    async def get(self, key: str) -> Optional[str]:
        """Get a value"""
        return await self._command("GET", key)

    async def set(self, key: str, value: str, ttl: Optional[int] = None) -> None:
        """Set a value"""
        if ttl:
            await self._command("SET", key, value, "EX", ttl)
        else:
            await self._command("SET", key, value)

    async def delete(self, key: str) -> bool:
        """Delete a key"""
        return (await self._command("DEL", key)) > 0

    async def exists(self, key: str) -> bool:
        """Check if key exists"""
        return (await self._command("EXISTS", key)) > 0

    async def incr(self, key: str) -> int:
        """Increment value"""
        return await self._command("INCR", key)

    async def decr(self, key: str) -> int:
        """Decrement value"""
        return await self._command("DECR", key)

    async def incrby(self, key: str, amount: int) -> int:
        """Increment by amount"""
        return await self._command("INCRBY", key, amount)

    async def decrby(self, key: str, amount: int) -> int:
        """Decrement by amount"""
        return await self._command("DECRBY", key, amount)

    async def mget(self, *keys: str) -> list[Optional[str]]:
        """Get multiple values"""
        return await self._command("MGET", *keys)

    async def mset(self, entries: dict[str, str]) -> None:
        """Set multiple values"""
        args = ["MSET"]
        for k, v in entries.items():
            args.extend([k, v])
        await self._command(*args)

    async def keys(self, pattern: str) -> list[str]:
        """Find keys matching pattern"""
        return await self._command("KEYS", pattern)

    async def expire(self, key: str, seconds: int) -> bool:
        """Set key expiration"""
        return (await self._command("EXPIRE", key, seconds)) > 0

    async def ttl(self, key: str) -> int:
        """Get key TTL"""
        return await self._command("TTL", key)

    async def persist(self, key: str) -> bool:
        """Remove key expiration"""
        return (await self._command("PERSIST", key)) > 0

    async def dbsize(self) -> int:
        """Get number of keys"""
        return await self._command("DBSIZE")

    async def flushdb(self) -> None:
        """Delete all keys"""
        await self._command("FLUSHDB")

    async def info(self) -> str:
        """Get server info"""
        return await self._command("INFO")

    async def ping(self) -> str:
        """Ping the server"""
        return await self._command("PING")
