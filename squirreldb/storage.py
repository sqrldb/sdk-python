"""
SquirrelDB Python SDK - Storage (S3-compatible)
Generated by sdk-generator v0.1.0
DO NOT EDIT MANUALLY
"""

import re
from dataclasses import dataclass
from typing import Optional
import urllib.request
import urllib.error


@dataclass
class Bucket:
    name: str
    created_at: str


@dataclass
class StorageObject:
    key: str
    size: int
    etag: str
    last_modified: str
    content_type: Optional[str] = None


class StorageError(Exception):
    def __init__(self, status: int, message: str):
        self.status = status
        self.message = message
        super().__init__(f"Storage error {status}: {message}")


class Storage:
    """S3-compatible storage client"""

    def __init__(
        self,
        endpoint: str,
        access_key: Optional[str] = None,
        secret_key: Optional[str] = None,
        region: str = "us-east-1",
    ):
        self._endpoint = endpoint.rstrip("/")
        self._access_key = access_key
        self._secret_key = secret_key
        self._region = region

    @classmethod
    def connect(
        cls,
        endpoint: str,
        access_key: Optional[str] = None,
        secret_key: Optional[str] = None,
        region: str = "us-east-1",
    ) -> "Storage":
        """Create a new storage client"""
        return cls(endpoint, access_key, secret_key, region)

    def _request(
        self,
        method: str,
        path: str,
        body: Optional[bytes] = None,
        headers: Optional[dict[str, str]] = None,
    ) -> tuple[int, bytes, dict[str, str]]:
        url = f"{self._endpoint}{path}"
        req_headers = headers or {}

        if self._access_key:
            req_headers["x-amz-access-key-id"] = self._access_key

        req = urllib.request.Request(url, data=body, headers=req_headers, method=method)

        try:
            with urllib.request.urlopen(req) as response:
                return response.status, response.read(), dict(response.headers)
        except urllib.error.HTTPError as e:
            raise StorageError(e.code, e.read().decode())

    def list_buckets(self) -> list[Bucket]:
        """List all buckets"""
        _, body, _ = self._request("GET", "/")
        text = body.decode()
        matches = re.findall(r"<Name>([^<]+)</Name>", text)
        return [Bucket(name=m, created_at="") for m in matches]

    def create_bucket(self, name: str) -> None:
        """Create a bucket"""
        self._request("PUT", f"/{name}")

    def delete_bucket(self, name: str) -> None:
        """Delete a bucket"""
        self._request("DELETE", f"/{name}")

    def bucket_exists(self, name: str) -> bool:
        """Check if bucket exists"""
        try:
            self._request("HEAD", f"/{name}")
            return True
        except StorageError:
            return False

    def list_objects(
        self, bucket: str, prefix: Optional[str] = None, max_keys: Optional[int] = None
    ) -> list[StorageObject]:
        """List objects in bucket"""
        params = []
        if prefix:
            params.append(f"prefix={prefix}")
        if max_keys:
            params.append(f"max-keys={max_keys}")
        query = f"?{'&'.join(params)}" if params else ""

        _, body, _ = self._request("GET", f"/{bucket}{query}")
        text = body.decode()
        matches = re.findall(
            r"<Key>([^<]+)</Key>.*?<Size>(\d+)</Size>.*?<ETag>([^<]+)</ETag>",
            text,
            re.DOTALL,
        )
        return [
            StorageObject(key=m[0], size=int(m[1]), etag=m[2].strip('"'), last_modified="")
            for m in matches
        ]

    def get_object(self, bucket: str, key: str) -> bytes:
        """Get object content"""
        _, body, _ = self._request("GET", f"/{bucket}/{key}")
        return body

    def put_object(
        self,
        bucket: str,
        key: str,
        data: bytes,
        content_type: Optional[str] = None,
    ) -> str:
        """Upload object"""
        headers = {}
        if content_type:
            headers["content-type"] = content_type
        _, _, resp_headers = self._request("PUT", f"/{bucket}/{key}", data, headers)
        return resp_headers.get("etag", "").strip('"')

    def delete_object(self, bucket: str, key: str) -> None:
        """Delete object"""
        self._request("DELETE", f"/{bucket}/{key}")

    def object_exists(self, bucket: str, key: str) -> bool:
        """Check if object exists"""
        try:
            self._request("HEAD", f"/{bucket}/{key}")
            return True
        except StorageError:
            return False
